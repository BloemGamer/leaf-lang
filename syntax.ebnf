// ============================================================================
// GRAMMAR SPECIFICATION
// ============================================================================

// --- Comments ---
line_comment  = "//" , { character - "\n" } , "\n" ;
block_comment = "/*" , { character } , "*/" ;
doc_comment   = "///" , { character - "\n" } , "\n"
              | "/**" , { character } , "*/" ;

comment = line_comment | block_comment | doc_comment ;

// --- Basic lexical elements ---
letter     = "A"…"Z" | "a"…"z" ;
digit      = "0"…"9" ;
hex_digit  = digit | "A"…"F" | "a"…"f" ;
character  = ? any Unicode character ? ;

// --- Identifiers ---
identifier = ( letter | "_" ) , { letter | digit | "_" } ;
path = identifier , { "::" , identifier } ;

// Label for loops: 'label:
label = "'" , identifier ;

// --- Literals ---
integer_literal = decimal_literal
                | hex_literal
                | binary_literal
                | octal_literal ;

decimal_literal = digit , { digit | "_" } ;
hex_literal     = "0x" , hex_digit , { hex_digit | "_" } ;
binary_literal  = "0b" , ( "0" | "1" ) , { ( "0" | "1" ) | "_" } ;
octal_literal   = "0o" , ( "0"…"7" ) , { ( "0"…"7" ) | "_" } ;

float_literal = digit , { digit | "_" } , "." , digit , { digit | "_" } ;

string_literal = '"' , { character - '"' | escape_sequence } , '"' ;
char_literal   = "'" , ( character - "'" | escape_sequence ) , "'" ;

escape_sequence = "\" , ( "n" | "t" | "r" | "0" | "\" | "'" | '"' ) ;

boolean_literal = "true" | "false" ;

// --- Array literals ---
// [1, 2, 3] or [value; count] or []
array_literal = "[" , [ array_content ] , "]" ;
array_content = expression , ( ";" , expression )  // repeat: [0; 10]
              | expression , { "," , expression } , [ "," ] ; // list: [1, 2, 3]

// --- Tuple literals ---
// () or (1,) or (1, 2, 3)
tuple_literal = "(" , [ tuple_content ] , ")" ;
tuple_content = expression , "," , [ expression , { "," , expression } , [ "," ] ] ;

// --- Struct literals ---
// Point { x = 10, y = 20 }
struct_literal = path , "{" , [ struct_field_list ] , "}" ;
struct_field_list = struct_field , { "," , struct_field } , [ "," ] ;
struct_field = identifier , "=" , expression ;

// --- Range expressions ---
// 1..10 or 1..=10 or 1.. or ..10 or ..
range_expr = [ expression ] , ( ".." | "..=" ) , [ expression ] ;

// ============================================================================
// OPERATORS
// ============================================================================

// Assignment operators
assign_op = "=" | "+=" | "-=" | "*=" | "/=" | "%="
          | "&=" | "|=" | "^=" | "~=" | ">>=" | "<<=" ;

// Binary operators (by precedence level)
logical_or_op  = "||" ;
logical_and_op = "&&" ;
equality_op    = "==" | "!=" ;
relational_op  = "<" | ">" | "<=" | ">=" ;
bitwise_or_op  = "|" ;
bitwise_xor_op = "^" ;
bitwise_and_op = "&" ;
shift_op       = "<<" | ">>" ;
additive_op    = "+" | "-" ;
multiplicative_op = "*" | "/" | "%" ;

// Unary operators
unary_op = "-"           // negation
         | "!"           // logical NOT
         | "*"           // dereference
         | "&" , [ "mut" ] ; // address-of

// ============================================================================
// EXPRESSIONS (with precedence from lowest to highest)
// ============================================================================

expression = logical_or_expr ;

// Precedence level 1: Logical OR
logical_or_expr = logical_and_expr , { logical_or_op , logical_and_expr } ;

// Precedence level 2: Logical AND
logical_and_expr = bitwise_or_expr , { logical_and_op , bitwise_or_expr } ;

// Precedence level 3: Bitwise OR
bitwise_or_expr = bitwise_xor_expr , { bitwise_or_op , bitwise_xor_expr } ;

// Precedence level 4: Bitwise XOR
bitwise_xor_expr = bitwise_and_expr , { bitwise_xor_op , bitwise_and_expr } ;

// Precedence level 5: Bitwise AND
bitwise_and_expr = equality_expr , { bitwise_and_op , equality_expr } ;

// Precedence level 6: Equality
equality_expr = relational_expr , { equality_op , relational_expr } ;

// Precedence level 7: Relational/Comparison
relational_expr = shift_expr , { relational_op , shift_expr } ;

// Precedence level 8: Shift
shift_expr = range_expr , { shift_op , range_expr } ;

// Precedence level 9: Range
range_expr = additive_expr , [ ( ".." | "..=" ) , [ additive_expr ] ] ;

// Precedence level 10: Additive
additive_expr = multiplicative_expr , { additive_op , multiplicative_expr } ;

// Precedence level 11: Multiplicative
multiplicative_expr = cast_expr , { multiplicative_op , cast_expr } ;

// Precedence level 12: Cast
// Cast: (type)expr
cast_expr = "(" , type , ")" , cast_expr
          | unary_expr ;

// Precedence level 13: Unary
unary_expr = unary_op , unary_expr
           | postfix_expr ;

// Precedence level 14: Postfix (field access, indexing, calls)
postfix_expr = primary_expr , { postfix_op } ;

postfix_op = "." , identifier                      // field access
           | "[" , expression , "]"                // array indexing
           | "(" , [ argument_list ] , ")" ;       // function call

argument_list = expression , { "," , expression } , [ "," ] ;

// Precedence level 15: Primary expressions
primary_expr = path
             | integer_literal
             | float_literal
             | string_literal
             | char_literal
             | boolean_literal
             | array_literal
             | tuple_literal
             | struct_literal
             | block_expr
             | unsafe_block_expr
             | switch_expr
             | if_expr
             | loop_expr
             | "default"
             | "self"
             | "(" , expression , ")" ;

// ============================================================================
// BLOCK AND CONTROL FLOW EXPRESSIONS
// ============================================================================

// Block expression: { stmt; stmt; expr }
block_expr = "{" , block_content , "}" ;

block_content = { statement } , [ expression ] ;

// Unsafe block: unsafe { ... }
unsafe_block_expr = "unsafe" , block_expr ;

// Switch expression: switch expr { pattern => expr, }
switch_expr = "switch" , expression , "{" , { switch_arm } , "}" ;

switch_arm = pattern , "=>" , switch_arm_body ;

switch_arm_body = expression , ","      // expression arm
                | block_expr , [ "," ] ; // block arm

// If expression: if cond { } else { }
if_expr = "if" , [ "var" ] , if_condition , block_expr , 
          [ "else" , ( block_expr | if_expr ) ] ;

if_condition = pattern , "=" , expression  // if var pattern = expr
             | expression ;                // if expr

// Loop expression: loop { } or 'label: loop { }
loop_expr = [ label , ":" ] , "loop" , block_expr ;

// ============================================================================
// PATTERNS
// ============================================================================

pattern = or_pattern ;

or_pattern = and_pattern , { "|" , and_pattern } ;

and_pattern = wildcard_pattern
            | literal_pattern
            | typed_identifier_pattern
            | variant_pattern
            | tuple_pattern
            | struct_pattern
            | range_pattern ;

wildcard_pattern = "_" , [ ":" , type ] ;

literal_pattern = integer_literal
                | float_literal
                | string_literal
                | char_literal
                | boolean_literal ;

typed_identifier_pattern = identifier , ":" , type ;

variant_pattern = path , [ "(" , [ pattern_list ] , ")" ] ;

tuple_pattern = "(" , [ pattern_list ] , ")" ;

struct_pattern = path , "{" , [ struct_pattern_field_list ] , "}" ;

struct_pattern_field_list = struct_pattern_field , { "," , struct_pattern_field } , [ "," ] ;
struct_pattern_field = identifier , ":" , pattern ;

range_pattern = [ expression ] , ( ".." | "..=" ) , [ expression ] ;

pattern_list = pattern , { "," , pattern } , [ "," ] ;

// ============================================================================
// TYPES
// ============================================================================

type = [ type_modifier , { type_modifier } ] , type_core ;

type_core = reference_type
          | base_type
          | tuple_type ;

// Reference type: &T or &mut T
reference_type = "&" , [ "mut" ] , type_core ;

// Base type: Name<T, U> followed by suffixes
base_type = path , [ generic_args ] , { type_suffix } ;

// Type suffixes: pointers
type_suffix = "*"                          // pointer: T*
            | "[" , [ expression ] , "]" ; // array: T[10]

// Tuple type: (T, U) or () or (T,)
tuple_type = "(" , [ type , { "," , type } , [ "," ] ] , ")" ;

// Generic arguments: <T, U>
generic_args = "<" , type , { "," , type } , [ "," ] , ">" ;

// Type modifiers
type_modifier = "const" | "volatile" | directive ;

// ============================================================================
// STATEMENTS
// ============================================================================

statement = [ label , ":" ] , statement_kind ;

statement_kind = variable_decl_stmt
               | assignment_stmt
               | return_stmt
               | break_stmt
               | continue_stmt
               | expr_stmt
               | if_stmt
               | while_stmt
               | for_stmt
               | loop_stmt
               | delete_stmt
               | unsafe_stmt
               | block_stmt
               | directive_stmt ;

// Variable declaration: var x: i32 = 5; or const X: i32 = 5; or var x: i64();
variable_decl_stmt = ( "var" | "const" ) , pattern , [ ( "(" , ")" ) | ( "=" , expression ) ] , ";" ;

// Assignment: x = 5; or x += 5;
assignment_stmt = expression , assign_op , expression , ";" ;

// Return: return; or return expr;
return_stmt = "return" , [ expression ] , ";" ;

// Break: break; or break 'label; or break expr; or break 'label expr;
break_stmt = "break" , [ label ] , [ expression ] , ";" ;

// Continue: continue; or continue 'label;
continue_stmt = "continue" , [ label ] , ";" ;

// Expression statement: expr;
expr_stmt = expression , ";" ;

// If statement: if cond { } else { }
if_stmt = "if" , [ "var" ] , if_condition , block_expr ,
          [ "else" , ( block_expr | if_stmt ) ] ;

// While statement: while cond { } or while var pattern = expr { }
while_stmt = "while" , [ "var" ] , while_condition , block_expr ;

while_condition = "while" , pattern , "=" , expression  // while var pattern = expr
                | expression ;                          // while expr

// For statement: for x in iter { }
for_stmt = "for" , path , "in" , expression , block_expr ;

// Loop statement: loop { }
loop_stmt = "loop" , block_expr ;

// Delete statement: delete ptr;
delete_stmt = "delete" , path , ";" ;

// Unsafe statement: unsafe { }
unsafe_stmt = "unsafe" , block_expr ;

// Block statement: { }
block_stmt = block_expr ;

// Directive statement: @directive; or @directive { }
directive_stmt = directive_node ;

// ============================================================================
// DIRECTIVES
// ============================================================================

directive_node = directive , [ directive_body ] ;

directive_body = "{" , ( block_content | program ) , "}" ;

directive = import_directive
          | use_directive
          | custom_directive ;

import_directive = "@import" , string_literal ;

use_directive = "@use" , path ;

custom_directive = "@" , identifier , [ "(" , [ argument_list ] , ")" ] ;

// ============================================================================
// MODIFIERS
// ============================================================================

modifier = "pub"
         | "unsafe"
         | "inline"
         | "const"
         | "volatile"
         | directive ;

modifier_list = { modifier } ;

// ============================================================================
// FUNCTION DECLARATIONS
// ============================================================================

function_decl = function_signature , ( block_expr | ";" ) ;

function_signature = modifier_list ,
                     "fn" ,
                     [ "!" ] ,  // heap-allocated function
                     path ,
                     [ generic_params ] ,
                     "(" , [ parameter_list ] , ")" ,
                     [ "->" , type ] ,
                     [ where_clause ] ;

// Generic parameters: <T, U>
generic_params = "<" , identifier , { "," , identifier } , [ "," ] , ">" ;

// Function parameters
parameter_list = parameter , { "," , parameter } , [ "," ] ;

parameter = self_parameter
          | regular_parameter ;

self_parameter = [ "&" , [ "mut" ] ] , "self" ;

regular_parameter = path , ":" , type ;

// Where clause: where T: Trait1 + Trait2, U: Trait3
where_clause = "where" , constraint , { "," , constraint } , [ "," ] ;

constraint = path , ":" , trait_bound_list ;

trait_bound_list = path , { "+" , path } ;

// ============================================================================
// TYPE DECLARATIONS
// ============================================================================

// Struct: struct Point { x: i32, y: i32 }
struct_decl = modifier_list ,
              "struct" ,
              path ,
              "{" , [ struct_field_decl_list ] , "}" ;

struct_field_decl_list = struct_field_decl , { "," , struct_field_decl } , [ "," ] ;

struct_field_decl = identifier , ":" , type , [ "=" , expression ] ;

// Union: union Data { i: i32, f: f64 }
union_decl = modifier_list ,
             "union" ,
             path ,
             "{" , [ union_field_decl_list ] , "}" ;

union_field_decl_list = union_field_decl , { "," , union_field_decl } , [ "," ] ;

union_field_decl = identifier , ":" , type ;

// Enum (C-style): enum Color { Red, Green, Blue }
enum_decl = modifier_list ,
            "enum" ,
            path ,
            "{" , [ enum_variant_list ] , "}" ;

enum_variant_list = enum_variant , { "," , enum_variant } , [ "," ] ;

enum_variant = identifier , [ "=" , expression ] ;

// Variant (Rust-style enum): variant Option { Some(i32), None }
variant_decl = modifier_list ,
               "variant" ,
               path ,
               "{" , [ variant_variant_list ] , "}" ;

variant_variant_list = variant_variant , { "," , variant_variant } , [ "," ] ;

variant_variant = identifier , [ "(" , type , ")" ] , [ "=" , expression ] ; // "=" only for value variants, so it's easier to use with C

// Type alias: type Int = i32;
type_alias_decl = modifier_list ,
                  "type" ,
                  path ,
                  "=" ,
                  type ,
                  ";" ;

// ============================================================================
// TRAIT DECLARATIONS
// ============================================================================

trait_decl = modifier_list ,
             "trait" ,
             path ,
             [ generic_params ] ,
             [ ":" , trait_bound_list ] ,
             "{" , { trait_item } , "}" ;

trait_item = trait_function
           | trait_type_alias
           | trait_const ;

trait_function = function_signature , ( block_expr | ";" ) ;

trait_type_alias = modifier_list , "type" , path , "=" , type , ";" ;

trait_const = ( "var" | "const" ) , pattern , [ "=" , expression ] , ";" ;

// ============================================================================
// IMPL BLOCKS
// ============================================================================

impl_decl = modifier_list ,
            "impl" ,
            [ generic_params ] ,
            impl_target ,
            [ "for" , impl_target ] ,
            [ where_clause ] ,
            "{" , { impl_item } , "}" ;

impl_target = path , [ generic_args ] ;

impl_item = impl_function
          | impl_type_alias
          | impl_const ;

impl_function = function_decl ;

impl_type_alias = type_alias_decl ;

impl_const = ( "var" | "const" ) , pattern , [ "=" , expression ] , ";" ;

// ============================================================================
// NAMESPACE DECLARATIONS
// ============================================================================

namespace_decl = modifier_list ,
                 "namespace" ,
                 path ,
                 "{" , program , "}" ;

// ============================================================================
// TOP-LEVEL DECLARATIONS
// ============================================================================

top_level_decl = directive_stmt
               | variable_decl_stmt
               | function_decl
               | struct_decl
               | union_decl
               | enum_decl
               | variant_decl
               | type_alias_decl
               | trait_decl
               | impl_decl
               | namespace_decl ;

// ============================================================================
// PROGRAM (entry point)
// ============================================================================

program = { top_level_decl } ;

// ============================================================================
// NOTES ON OPERATOR PRECEDENCE AND PARSING
// ============================================================================
//
// Operator precedence (lowest to highest): // should be the same as C
//   1.  ||           (logical OR)
//   2.  &&           (logical AND)
//   3.  |            (bitwise OR)
//   4.  ^            (bitwise XOR)
//   5.  &            (bitwise AND)
//   6.  == !=        (equality)
//   7.  < > <= >=    (relational)
//   8.  << >>        (shift)
//   9.  .. ..=       (range)
//  10.  + -          (additive)
//  11.  * / %        (multiplicative)
//  12.  (type)       (cast)
//  13.  ! - * &      (unary)
//  14.  . [] ()      (postfix)
//  15.  literals, identifiers, blocks (primary)
//
// Type structure examples:
//   - i32
//   - &mut Vec<i32>
//   - i32*
//   - i32[10][20]
//   - &String*[5]
//   - (i32, bool)
//   - ()
//
// Block with tail expression:
//   {
//     var x: i32 = 5;
//     x + 1  // No semicolon: this is the block's value
//   }
//
// Labeled loops:
//   'outer: loop {
//     'inner: loop {
//       break 'outer;  // breaks out of outer loop
//     }
//   }
//
// Break with value:
//   var result: i32 = loop {
//     if condition {
//       break 42;  // loop evaluates to 42
//     }
//   };
//
// If-var (pattern matching if):
//   if var Some(x: i32) = opt {
//     // x is bound here
//   }
//
// While-var (pattern matching while):
//   while var Some(x: i32) = iter.next() {
//     // x is bound here
//   }
//
// Switch expression (must be exhaustive):
//   switch x {
//     1 => 10,
//     2 => { println("two"); 20 },
//     _ => 0,
//   }
//
// Struct with default field values:
//   struct Point {
//     x: i32 = 0,
//     y: i32 = 0,
//   }
//
// Special keywords:
//   - default: represents default value for a value a struct
//   - self: current instance
//
// ============================================================================
